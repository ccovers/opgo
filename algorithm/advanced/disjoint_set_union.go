package main

import (
	"fmt"
)

/*
* 并查集：
	并查集，在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。这一类问题近几年来反复出现在信息学的国际国内赛题中，其特点是看似并不复杂，但数据量极大，若用正常的数据结构来描述的话，往往在空间上过大，计算机无法承受；即使在空间上勉强通过，运行的时间复杂度也极高，根本就不可能在比赛规定的运行时间（1～3秒）内计算出试题需要的结果，只能用并查集来描述。
* 并查集是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。常常在使用中以森林来表示。

* 初始化：
	先初始化所有的结点，将每一个结点的父结点都指向自己，这时候我们就构建好了一颗颗只有一个结点的树
* 查找：
	我们根据某个点的父结点是否是它本身来判断其是否是根结点，如果有 pre[ i ] = i  ，那么它就是父结点
* 路径压缩优化：
	但是大家有没有发现，这样子虽然可以找到父结点，可是每次查找的时候都要从当前结点位置一步一步地走到根节点处才能返回答案，如果数据量较大的时候，显然是会爆的，所以我们新学一招：路径压缩————将某个根结点下的所有子结点都指向该根结点如此一来，我们就可以直接从目标结点的位置一步找到其根结点
* 合并：
	别忘了还有一个重要步骤，如果要将两个集合合并起来，我们也需要一个函数

*/

var pre []int

func main() {
	// 记录每个节点的父节点
	pre = make([]int, 10000)
	for i := 0; i < 10000; i++ {
		pre[i] = i // 初始化：每个结点的父结点初始化为自己
	}
	for i := 0; i < 10; i++ {
		// 查找：判断根结点是否相同
		if find(0) == find(i) {
			fmt.Printf("%d - %d: YES\n", 0, i)
		} else {
			fmt.Printf("%d - %d: NO\n", 0, i)
			merge(0, i) // 合并
		}
	}
	for i := 0; i < 10; i++ {
		// 查找：判断根结点是否相同
		if find(0) == find(i) {
			fmt.Printf("%d - %d: YES\n", 0, i)
		} else {
			fmt.Printf("%d - %d: NO\n", 0, i)
		}
	}
}

// 寻找k的根节点
func find(k int) int {
	if pre[k] == k {
		return k // 我们以pre的值是否是自身下标来判断根结点
	}
	pre[k] = find(pre[k]) // 路径压缩优化：递归路径压缩
	return pre[k]
}

// 合并集合
func merge(a, b int) {
	t1 := find(a) // 找到a和b的根结点
	t2 := find(b) // 靠右，即把左边的集合变成右边的子集合
	if t1 != t2 {
		pre[t1] = t2
	}
}
